# IMPORTACIONES
# ========================
import cv2
import numpy as np
import time
from collections import deque
import threading
import socket
import atexit
from picamera2 import Picamera2

# ========================
# CONFIGURACIÓN DEL PLANO
# ========================
PLANO_X_MIN = -5.0
PLANO_X_MAX = 5.0
PLANO_Y_MIN = -5.0
PLANO_Y_MAX = 5.0

# ========================
# CONFIGURACIÓN DE RED
# ========================
ESP32_IP = '10.42.0.42'  # IP de la ESP32
ESP32_PORT = 8080           # Puerto de comunicación
SEND_INTERVAL = 0.5         # Intervalo de envío aumentado (500ms)
TIMEOUT = 5.0               # Timeout para conexión

# ========================
# PARÁMETROS DE DETECCIÓN DE PIEL
# ========================
lower_skin = np.array([0, 71, 50])      # Límite inferior (H,S,V)
upper_skin = np.array([179, 246, 255])  # Límite superior (H,S,V)
erosion_iter = 1                        # Iteraciones de erosión
dilatacion_iter = 2                     # Iteraciones de dilatación
blur_size = 5                           # Tamaño de desenfoque

# ========================
# INICIALIZACIÓN DE CÁMARA CSI
# ========================
picam2 = Picamera2()  # Objeto para cámara CSI
config = picam2.create_preview_configuration(
    main={"size": (640, 480), "format": "RGB888"}
)
picam2.configure(config)
picam2.start()

# ========================
# PARÁMETROS DE SUAVIZADO Y DETECCIÓN
# ========================
MAX_HISTORY = 5               # Tamaño del historial para suavizado
MAX_SPEED = 30                # Velocidad máxima permitida
MIN_SPEED = 0.1               # Velocidad mínima para grabar (en unidades del plano)
OSCILLATION_THRESHOLD = 0.1   # Umbral para detectar oscilaciones (en unidades)

# ========================
# PARÁMETROS DEL PLANO DE TRABAJO
# ========================
PLANO_WIDTH = 600    # Ancho del plano visual
PLANO_HEIGHT = 600   # Alto del plano visual
PLANO_MARGIN = 40    # Margen del plano

# ========================
# VARIABLES GLOBALES
# ========================
socket_client = None          # Cliente de socket TCP
socket_connected = False      # Estado de conexión
full_trajectory = []          # Trayectoria completa en coordenadas del plano (-5 a 5)
plano_display_points = []     # Trayectoria en pixels para mostrar
recording = False             # Estado de grabación
last_plano_position = None    # Última posición en coordenadas del plano
movement_start_time = None    # Tiempo de inicio de movimiento
movement_blocked = False      # Bloqueo por movimiento brusco
blocked_until = 0             # Tiempo hasta desbloqueo
last_send_time = 0            # Último tiempo de envío
trajectory_lock = threading.Lock()  # Lock para sincronización
positions = deque(maxlen=MAX_HISTORY)  # Historial de posiciones en pixels
frame_counter = 0             # Contador de frames
mode = "MENU"                 # Modo actual: MENU, WIFI, SIMULADOR, MANUAL
last_sent_coords = None       # Últimas coordenadas enviadas

# ========================
# FUNCIÓN: CONEXIÓN SOCKET
# ========================
def init_socket_connection():
    """Establece conexión TCP con la ESP32"""
    global socket_client, socket_connected
    
    # Cerrar conexión previa si existe
    if socket_client:
        try:
            socket_client.close()
        except:
            pass

    try:
        print(f"\nConectando a {ESP32_IP}:{ESP32_PORT}...")

        # Crear socket TCP
        socket_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        socket_client.settimeout(TIMEOUT)
        socket_client.connect((ESP32_IP, ESP32_PORT))
        socket_client.settimeout(0.1)  # Timeout corto para recibir

        # Enviar ping de prueba
        socket_client.sendall(b"PING\n")

        # Intentar recibir respuesta
        try:
            response = socket_client.recv(1024).decode().strip()
            print(f"ESP32 responde: {response}")
        except socket.timeout:
            print("ESP32 conectada (sin respuesta)")
        except:
            print("ESP32 conectada")

        socket_connected = True
        return True

    except socket.error as e:
        print(f"ERROR de conexión: {e}")
        socket_client = None
        socket_connected = False
        return False

# ========================
# FUNCIÓN: ENVIAR A ESP32
# ========================
def send_to_esp32_socket(x, y):
    """Envía coordenadas a la ESP32 vía TCP (en coordenadas del plano -5 a 5)"""
    global socket_client, socket_connected, last_sent_coords
    
    # Verificar conexión
    if not socket_connected or socket_client is None:
        print("ERROR: Sin conexión WiFi")
        return False
    
    try:
        # Formato simple: X,Y\n
        message = f"{x:.2f},{y:.2f}\n"
        
        # Enviar datos
        socket_client.sendall(message.encode('utf-8'))
        
        # Guardar últimas coordenadas enviadas
        last_sent_coords = (x, y)
        
        print(f"✓ Enviado a SCARA: X={x:.2f}, Y={y:.2f}")
        return True

    except socket.error as e:
        print(f"ERROR al enviar: {e}")
        socket_connected = False
        return False

# ========================
# FUNCIÓN: ENVIAR COMANDO STOP
# ========================
def send_stop_command():
    """Envía comando de parada a la ESP32"""
    global socket_client, socket_connected
    if socket_connected and socket_client:
        try:
            socket_client.sendall(b"STOP\n")
            print("✓ Comando STOP enviado")
        except:
            pass

# ========================
# FUNCIÓN: LIMPIEZA AL SALIR
# ========================
def cleanup():
    """Libera recursos al terminar el programa"""
    global socket_client, socket_connected
    
    # Enviar comando de parada
    if socket_connected and socket_client:
        send_stop_command()
        try:
            socket_client.close()
        except:
            pass
        socket_connected = False
    
    # Detener cámara
    try:
        picam2.stop()
    except:
        pass
    
    # Cerrar ventanas
    cv2.destroyAllWindows()

# ========================
# FUNCIÓN: CREAR PLANO VISUAL CON COORDENADAS -5 A 5
# ========================
def create_plano():
    """Crea el plano de trabajo con grid, ejes y coordenadas -5 a 5"""
    plano = np.ones((PLANO_HEIGHT, PLANO_WIDTH, 3), dtype=np.uint8) * 240
    
    # Calcular espaciado del grid (cada unidad)
    grid_spacing = PLANO_WIDTH // 10  # 10 divisiones de -5 a 5
    
    # Centro del plano
    center_x = PLANO_WIDTH // 2
    center_y = PLANO_HEIGHT // 2
    
    # Líneas verticales del grid
    for i in range(0, PLANO_WIDTH + 1, grid_spacing):
        if i == center_x:
            continue  # No dibujar sobre el eje Y
        cv2.line(plano, (i, 0), (i, PLANO_HEIGHT), (220, 220, 220), 1)
    
    # Líneas horizontales del grid
    for i in range(0, PLANO_HEIGHT + 1, grid_spacing):
        if i == center_y:
            continue  # No dibujar sobre el eje X
        cv2.line(plano, (0, i), (PLANO_WIDTH, i), (220, 220, 220), 1)
    
    # Ejes coordenados principales
    cv2.line(plano, (center_x, 0), (center_x, PLANO_HEIGHT), (0, 0, 0), 2)
    cv2.line(plano, (0, center_y), (PLANO_WIDTH, center_y), (0, 0, 0), 2)
    
    # Etiquetas de ejes
    cv2.putText(plano, "Y", (center_x + 15, 30), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 0), 2)
    cv2.putText(plano, "X", (PLANO_WIDTH - 30, center_y - 15), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 0), 2)
    
    # Marcas y números en ejes (-5 a 5)
    for i in range(-5, 6):
        # Posición en pixels
        x_pos = center_x + (i * grid_spacing)
        y_pos = center_y - (i * grid_spacing)
        
        # Marcas en eje X
        cv2.line(plano, (x_pos, center_y - 5), (x_pos, center_y + 5), (0, 0, 0), 2)
        if i != 0:  # No poner número en el origen
            cv2.putText(plano, str(i), (x_pos - 10, center_y + 25), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1)
        
        # Marcas en eje Y
        cv2.line(plano, (center_x - 5, y_pos), (center_x + 5, y_pos), (0, 0, 0), 2)
        if i != 0:  # No poner número en el origen
            cv2.putText(plano, str(-i), (center_x - 25, y_pos + 5), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1)
    
    # Origen (0,0)
    cv2.circle(plano, (center_x, center_y), 8, (0, 0, 255), -1)
    cv2.putText(plano, "0", (center_x + 10, center_y - 10), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)
    
    return plano

# ========================
# FUNCIÓN: CONVERTIR DE CÁMARA A COORDENADAS DEL PLANO (-5 a 5)
# ========================
def cam_to_plano_coords(cam_x, cam_y, cam_width=640, cam_height=480):
    """
    Convierte coordenadas de píxeles de cámara a coordenadas del plano (-5 a 5)
    CORREGIDO: Ahora coincide con la interpretación del ESP32
    
    Mapeo:
    - Cámara arriba (y=0) -> Plano Y = +5 (arriba)
    - Cámara abajo (y=480) -> Plano Y = -5 (abajo)
    - Cámara izquierda (x=0) -> Plano X = -5 (izquierda)
    - Cámara derecha (x=640) -> Plano X = +5 (derecha)
    """
    # Para X: 0 -> -5, 640 -> 5
    plano_x = PLANO_X_MIN + (cam_x / cam_width) * (PLANO_X_MAX - PLANO_X_MIN)
    
    # Para Y: 0 (arriba) -> +5, 480 (abajo) -> -5
    plano_y = PLANO_Y_MAX - (cam_y / cam_height) * (PLANO_Y_MAX - PLANO_Y_MIN)
    
    # Limitar al rango del plano
    plano_x = max(PLANO_X_MIN, min(PLANO_X_MAX, plano_x))
    plano_y = max(PLANO_Y_MIN, min(PLANO_Y_MAX, plano_y))
    
    return round(plano_x, 2), round(plano_y, 2)

# ========================
# FUNCIÓN: CONVERTIR DE COORDENADAS DEL PLANO A PIXELS DE DISPLAY
# ========================
def plano_to_display_coords(plano_x, plano_y):
    """Convierte coordenadas del plano (-5 a 5) a píxeles para mostrar"""
    # Asegurar que estén dentro del rango
    plano_x = max(PLANO_X_MIN, min(PLANO_X_MAX, plano_x))
    plano_y = max(PLANO_Y_MIN, min(PLANO_Y_MAX, plano_y))
    
    # Normalizar a 0-1
    norm_x = (plano_x - PLANO_X_MIN) / (PLANO_X_MAX - PLANO_X_MIN)
    norm_y = (plano_y - PLANO_Y_MIN) / (PLANO_Y_MAX - PLANO_Y_MIN)
    
    # Convertir a píxeles en el display (con márgenes)
    display_x = int(PLANO_MARGIN + norm_x * (PLANO_WIDTH - 2*PLANO_MARGIN))
    display_y = int(PLANO_HEIGHT - (PLANO_MARGIN + norm_y * (PLANO_HEIGHT - 2*PLANO_MARGIN)))
    
    return display_x, display_y

# ========================
# FUNCIÓN: SUAVIZAR POSICIÓN
# ========================
def calculate_smoothed_position(positions_list):
    """Suaviza la posición usando promedio ponderado"""
    if len(positions_list) == 0:
        return None
    
    # Ponderar posiciones recientes más
    weights = list(range(1, len(positions_list) + 1))
    total_weight = sum(weights)
    
    # Extraer coordenadas X e Y
    x_vals = [p[0] for p in positions_list]
    y_vals = [p[1] for p in positions_list]
    
    # Calcular promedio ponderado
    weighted_x = sum(x * w for x, w in zip(x_vals, weights)) / total_weight
    weighted_y = sum(y * w for y, w in zip(y_vals, weights)) / total_weight
    
    return (int(weighted_x), int(weighted_y))

# ========================
# FUNCIÓN: MANEJAR ERROR DE MOVIMIENTO
# ========================
def handle_movement_error():
    """Bloquea el sistema por movimiento brusco"""
    global movement_blocked, blocked_until
    movement_blocked = True
    blocked_until = time.time() + 2.0  # Bloquear por 2 segundos
    print("Movimiento demasiado rápido! Espera 2 segundos...")

# ========================
# FUNCIÓN: VERIFICAR BLOQUEO
# ========================
def check_movement_block():
    """Verifica si el sistema sigue bloqueado"""
    global movement_blocked
    if movement_blocked and time.time() > blocked_until:
        movement_blocked = False  # Restaurar sistema
        print("Sistema desbloqueado")

# ========================
# FUNCIÓN: RESETEAR SISTEMA
# ========================
def reset_system():
    """Resetea todas las variables del sistema"""
    global full_trajectory, plano_display_points, recording, last_plano_position
    global movement_blocked, last_send_time, positions, last_sent_coords
    
    with trajectory_lock:
        full_trajectory.clear()
        plano_display_points.clear()
    
    recording = False
    last_plano_position = None
    movement_blocked = False
    last_send_time = 0
    last_sent_coords = None
    positions.clear()
    
    print("✓ Sistema reseteado")

# ========================
# FUNCIÓN: ENVIAR COORDENADAS MANUALES
# ========================
def send_manual_coordinates():
    """Menú para enviar coordenadas manuales al SCARA"""
    global socket_connected, mode
    
    print("\n" + "="*50)
    print("   ENVÍO MANUAL DE COORDENADAS AL SCARA")
    print("="*50)
    
    # Verificar conexión
    if not socket_connected:
        print("ERROR: No hay conexión con el SCARA")
        print("1. Intentar reconectar")
        print("2. Volver al menú")
        
        choice = input("Selecciona (1-2): ").strip()
        if choice == "1":
            if init_socket_connection():
                print("✓ Conexión establecida")
            else:
                print("✗ No se pudo conectar")
                return
        else:
            return
    
    while True:
        print("\n" + "-"*40)
        print("OPCIONES:")
        print("1. Enviar coordenada específica")
        print("2. Enviar coordenadas predefinidas")
        print("3. Enviar comando STOP")
        print("4. Test de movimiento completo")
        print("5. Volver al menú principal")
        print("-"*40)
        
        choice = input("Selecciona (1-5): ").strip()
        
        if choice == "1":
            # Enviar coordenada específica
            try:
                x_str = input("Ingresa coordenada X (-5 a 5): ").strip()
                y_str = input("Ingresa coordenada Y (-5 a 5): ").strip()
                
                x = float(x_str)
                y = float(y_str)
                
                # Validar rango
                if not (PLANO_X_MIN <= x <= PLANO_X_MAX and PLANO_Y_MIN <= y <= PLANO_Y_MAX):
                    print(f"ERROR: Coordenadas fuera de rango ({PLANO_X_MIN} a {PLANO_X_MAX})")
                    continue
                
                print(f"\nEnviando: X={x:.2f}, Y={y:.2f}")
                if send_to_esp32_socket(x, y):
                    print("✓ Coordenada enviada correctamente")
                
                # Preguntar si esperar
                wait = input("¿Esperar 3 segundos antes de continuar? (s/n): ").strip().lower()
                if wait == 's':
                    print("Esperando 3 segundos...")
                    time.sleep(3)
                    
            except ValueError:
                print("ERROR: Ingresa números válidos")
                
        elif choice == "2":
            # Enviar coordenadas predefinidas
            print("\nCOORDENADAS PREDEFINIDAS:")
            print("1. Centro (0, 0)")
            print("2. Esquina inferior izquierda (-5, -5)")
            print("3. Esquina inferior derecha (5, -5)")
            print("4. Esquina superior derecha (5, 5)")
            print("5. Esquina superior izquierda (-5, 5)")
            print("6. Punto intermedio (-2.5, -2.5)")
            print("7. Punto intermedio (2.5, 2.5)")
            
            sub_choice = input("Selecciona punto (1-7): ").strip()
            
            points = {
                '1': (0.0, 0.0),
                '2': (-5.0, -5.0),
                '3': (5.0, -5.0),
                '4': (5.0, 5.0),
                '5': (-5.0, 5.0),
                '6': (-2.5, -2.5),
                '7': (2.5, 2.5)
            }
            
            if sub_choice in points:
                x, y = points[sub_choice]
                print(f"\nEnviando: X={x:.2f}, Y={y:.2f}")
                if send_to_esp32_socket(x, y):
                    print("✓ Coordenada enviada correctamente")
                
                wait = input("¿Esperar 3 segundos antes de continuar? (s/n): ").strip().lower()
                if wait == 's':
                    print("Esperando 3 segundos...")
                    time.sleep(3)
            else:
                print("Opción inválida")
                
        elif choice == "3":
            # Enviar STOP
            print("\nEnviando comando STOP...")
            send_stop_command()
            print("✓ Comando enviado")
            time.sleep(1)
            
        elif choice == "4":
            # Test completo
            print("\n=== TEST DE MOVIMIENTO COMPLETO ===")
            print("El SCARA se moverá a 5 puntos diferentes...")
            
            test_points = [
                (0.0, 0.0),      # Centro
                (-5.0, -5.0),    # Esquina 1
                (5.0, -5.0),     # Esquina 2
                (5.0, 5.0),      # Esquina 3
                (-5.0, 5.0),     # Esquina 4
                (0.0, 0.0)       # Volver al centro
            ]
            
            confirm = input("¿Iniciar test? (s/n): ").strip().lower()
            if confirm != 's':
                continue
            
            for i, (x, y) in enumerate(test_points):
                print(f"\nPunto {i+1}/{len(test_points)}: ({x:.1f}, {y:.1f})")
                
                if send_to_esp32_socket(x, y):
                    print(f"Enviado. Esperando 4 segundos...")
                    time.sleep(4)
                else:
                    print("✗ Error al enviar, deteniendo test...")
                    break
            
            print("\n✓ Test completado")
            
        elif choice == "5":
            # Volver al menú
            print("Volviendo al menú principal...")
            break
            
        else:
            print("Opción inválida")

# ========================
# FUNCIÓN: TEST DE MOVIMIENTO SIMPLE
# ========================
def test_simple_movement():
    """Test simple de movimiento"""
    global socket_connected
    
    if not socket_connected:
        print("ERROR: No hay conexión WiFi")
        return
    
    print("\n=== TEST SIMPLE DE MOVIMIENTO ===")
    
    # Puntos de prueba
    points = [(0, 0), (-5, -5), (5, -5), (5, 5), (-5, 5), (0, 0)]
    
    for i, (x, y) in enumerate(points):
        print(f"\n[{i+1}/{len(points)}] Moviendo a: ({x}, {y})")
        
        if send_to_esp32_socket(x, y):
            print(f"Esperando 3 segundos...")
            time.sleep(3)
        else:
            print("Error de conexión")
            break
    
    print("\n✓ Test completado")

# ========================
# CONFIGURAR LIMPIEZA AL SALIR
# ========================
atexit.register(cleanup)

# ========================
# FUNCIÓN: MOSTRAR MENÚ
# ========================
def show_menu():
    """Muestra el menú inicial"""
    global mode
    
    menu_screen = np.ones((480, 640, 3), dtype=np.uint8) * 50
    
    # Título
    cv2.putText(menu_screen, "CONTROL DE MANOS - SCARA", (80, 60), 
                cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 255, 255), 2)
    
    cv2.putText(menu_screen, "SELECCIONA MODO:", (120, 120), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
    
    # Opciones
    cv2.putText(menu_screen, "1. Conectar a WiFi (ESP32)", (100, 180), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
    cv2.putText(menu_screen, "2. Modo Simulador", (100, 220), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
    cv2.putText(menu_screen, "3. Enviar coordenadas manuales", (100, 260), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
    cv2.putText(menu_screen, "4. Test de movimiento", (100, 300), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
    cv2.putText(menu_screen, "Q. Salir", (100, 340), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
    
    # Teclas de control
    cv2.putText(menu_screen, "Durante operacion:", (100, 390), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 1)
    cv2.putText(menu_screen, "ESPACIO = Grabar/Parar", (120, 415), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200, 200, 200), 1)
    cv2.putText(menu_screen, "C = Limpiar trayectoria", (120, 440), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200, 200, 200), 1)
    cv2.putText(menu_screen, "M = Volver al menu", (120, 465), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200, 200, 200), 1)
    
    cv2.imshow('Control de Manos - Menu', menu_screen)
    
    # Esperar selección
    while True:
        key = cv2.waitKey(0) & 0xFF
        
        if key == ord('1'):
            mode = "WIFI"
            print("\nModo WiFi seleccionado")
            if init_socket_connection():
                return True
            else:
                print("No se pudo conectar. Intenta de nuevo o usa Simulador.")
                continue
        elif key == ord('2'):
            mode = "SIMULADOR"
            print("\nModo Simulador seleccionado")
            return True
        elif key == ord('3'):
            mode = "MANUAL"
            print("\nModo Manual seleccionado")
            cv2.destroyAllWindows()
            send_manual_coordinates()
            # Volver al menú después
            cv2.namedWindow('Control de Manos - Menu')
            show_menu()
            return False
        elif key == ord('4'):
            mode = "TEST"
            print("\nTest de movimiento seleccionado")
            cv2.destroyAllWindows()
            test_simple_movement()
            # Volver al menú después
            cv2.namedWindow('Control de Manos - Menu')
            show_menu()
            return False
        elif key == ord('q') or key == ord('Q'):
            print("Saliendo del programa...")
            cleanup()
            exit(0)
        else:
            print("Opción no válida. Presiona 1, 2, 3, 4 o Q.")

# ========================
# PROGRAMA PRINCIPAL
# ========================

# Crear plano inicial
plano = create_plano()

# Mostrar menú inicial
show_menu()

# ========================
# PARÁMETROS MEJORADOS PARA ENVÍO
# ========================
SEND_THRESHOLD = 1.0  # Solo enviar si se mueve más de 1.0 unidades
DEAD_ZONE = 0.3       # Zona muerta para evitar micro-movimientos

# ========================
# FUNCIÓN: DEBERÍA ENVIAR COORDENADAS?
# ========================
def should_send_coords(current_x, current_y, last_sent):
    """Determina si debe enviar nuevas coordenadas"""
    if last_sent is None:
        return True
    
    last_x, last_y = last_sent
    
    # Calcular distancia
    distance = np.sqrt((current_x - last_x)**2 + (current_y - last_y)**2)
    
    # Solo enviar si el movimiento es significativo
    if distance < DEAD_ZONE:
        return False  # Movimiento muy pequeño, ignorar
    
    return distance >= SEND_THRESHOLD

# ========================
# BUCLE PRINCIPAL
# ========================
try:
    while True:
        # Capturar frame de la cámara CSI
        frame = picam2.capture_array()

        # CAMBIO IMPORTANTE: Solo invertir horizontalmente (espejo)
        # Esto hace que el movimiento sea más intuitivo
        frame = cv2.flip(frame, 1)

        # Verificar si el sistema está bloqueado
        check_movement_block()

        # ========================
        # PROCESAMIENTO DE IMAGEN
        # ========================
        # Convertir a espacio de color HSV
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        # Crear máscara para color de piel
        mask = cv2.inRange(hsv, lower_skin, upper_skin)

        # Operaciones morfológicas
        kernel = np.ones((3, 3), np.uint8)
        if erosion_iter > 0:
            mask = cv2.erode(mask, kernel, iterations=erosion_iter)
        if dilatacion_iter > 0:
            mask = cv2.dilate(mask, kernel, iterations=dilatacion_iter)
        if blur_size > 1:
            mask = cv2.medianBlur(mask, blur_size)

        # Encontrar contornos
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        current_raw_position = None

        # ========================
        # DETECCIÓN DE MANO
        # ========================
        if contours:
            # Encontrar el contorno más grande (mano)
            largest = max(contours, key=cv2.contourArea)
            area = cv2.contourArea(largest)

            # Verificar si el área es suficiente
            if area > 300:
                # Obtener punto más alto del contorno (punta del dedo)
                topmost = tuple(largest[largest[:, :, 1].argmin()][0])
                cx, cy = topmost
                current_raw_position = (cx, cy)

                # Añadir al historial de posiciones (en píxeles)
                positions.append(current_raw_position)

                # Calcular posición suavizada (en píxeles)
                smoothed_pixel_pos = calculate_smoothed_position(positions)

                if smoothed_pixel_pos:
                    # CONVERTIR A COORDENADAS DEL PLANO (-5 a 5)
                    plano_x, plano_y = cam_to_plano_coords(smoothed_pixel_pos[0], smoothed_pixel_pos[1])
                    plano_pos = (plano_x, plano_y)
                    
                    movement_valid = True

                    # ========================
                    # VALIDACIÓN DE MOVIMIENTO
                    # ========================
                    if last_plano_position is not None:
                        # Calcular distancia en el plano
                        distance = np.sqrt((plano_x - last_plano_position[0])**2 + 
                                          (plano_y - last_plano_position[1])**2)
                        
                        # Convertir a píxeles aproximados para verificación
                        # 1 unidad del plano ≈ 60 píxeles en la cámara
                        distance_pixels = distance * 60
                        
                        if recording and not movement_blocked:
                            if distance_pixels > MAX_SPEED:
                                movement_valid = False
                                handle_movement_error()

                    # ========================
                    # PROCESAR MOVIMIENTO VÁLIDO
                    # ========================
                    if movement_valid and not movement_blocked:
                        # Mostrar coordenadas del plano en la cámara
                        cv2.circle(frame, smoothed_pixel_pos, 10, (0, 255, 0), -1)
                        cv2.putText(frame, f"X:{plano_x:.1f} Y:{plano_y:.1f}", 
                                   (smoothed_pixel_pos[0] - 60, smoothed_pixel_pos[1] - 20),
                                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

                        # Grabar si está en modo grabación
                        if recording:
                            current_time = time.time()
                            
                            # Verificar si el movimiento es significativo
                            if should_send_coords(plano_x, plano_y, last_sent_coords):
                                # Y si ha pasado suficiente tiempo
                                if current_time - last_send_time >= SEND_INTERVAL:
                                    with trajectory_lock:
                                        # Guardar en trayectorias
                                        full_trajectory.append(plano_pos)
                                        
                                        # Convertir a píxeles de display
                                        display_x, display_y = plano_to_display_coords(plano_x, plano_y)
                                        plano_display_points.append((display_x, display_y))

                                    # Enviar coordenadas según el modo
                                    if mode == "WIFI" and socket_connected:
                                        if send_to_esp32_socket(plano_x, plano_y):
                                            last_sent_coords = (plano_x, plano_y)
                                    elif mode == "SIMULADOR":
                                        print(f"Simulando SCARA: X={plano_x:.2f}, Y={plano_y:.2f}")
                                        last_sent_coords = (plano_x, plano_y)
                                    
                                    last_send_time = current_time

                        last_plano_position = plano_pos

                    # Dibujar contorno de la mano
                    cv2.drawContours(frame, [largest], -1, (255, 0, 0), 2)

        # ========================
        # DIBUJAR TRAYECTORIA EN PLANO
        # ========================
        plano_display = plano.copy()
        
        # Dibujar posición actual en el plano
        if last_plano_position is not None:
            display_x, display_y = plano_to_display_coords(last_plano_position[0], last_plano_position[1])
            
            # Punto actual (grande y rojo)
            cv2.circle(plano_display, (display_x, display_y), 8, (0, 0, 255), -1)
            
            # Etiqueta con coordenadas actuales
            coord_text = f"({last_plano_position[0]:.1f}, {last_plano_position[1]:.1f})"
            cv2.putText(plano_display, coord_text, (display_x + 10, display_y - 10),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)
        
        # Dibujar trayectoria completa en el plano
        if len(plano_display_points) > 1:
            for i in range(len(plano_display_points) - 1):
                color = (0, 0, 255) if recording else (100, 100, 100)
                cv2.line(plano_display, plano_display_points[i], plano_display_points[i+1], color, 2)

            # Dibujar puntos individuales
            for point in plano_display_points:
                cv2.circle(plano_display, point, 3, (0, 0, 255), -1)

        # ========================
        # MOSTRAR INFORMACIÓN EN PANTALLA
        # ========================
        # Estado de grabación
        status_text = "GRABANDO" if recording else "LISTO"
        status_color = (0, 0, 255) if recording else (0, 255, 0)
        
        # Panel de estado
        cv2.rectangle(frame, (5, 5), (300, 90), (0, 0, 0), -1)
        
        # Modo actual
        mode_text = f"Modo: {mode}"
        mode_color = (0, 255, 0) if mode == "WIFI" and socket_connected else (0, 165, 255) if mode == "WIFI" else (255, 255, 0)
        cv2.putText(frame, mode_text, (15, 30), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, mode_color, 2)
        
        # Estado de grabación
        cv2.putText(frame, status_text, (15, 60), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, status_color, 2)
        
        # Puntos capturados
        cv2.putText(frame, f"Puntos: {len(full_trajectory)}", (15, 85), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
        
        # Estado de conexión si es WiFi
        if mode == "WIFI":
            conn_status = "CONECTADO" if socket_connected else "DESCONECTADO"
            conn_color = (0, 255, 0) if socket_connected else (0, 0, 255)
            cv2.putText(frame, f"WiFi: {conn_status}", (400, 30), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, conn_color, 2)
        
        # Últimas coordenadas enviadas
        if last_sent_coords is not None and recording:
            cv2.putText(frame, f"Ultimo envio: X={last_sent_coords[0]:.2f}, Y={last_sent_coords[1]:.2f}", 
                       (10, 460), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 1)
        
        # Estado de bloqueo
        if movement_blocked:
            cv2.putText(frame, "MOVIMIENTO RAPIDO - BLOQUEADO", (150, 150),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
        
        # Instrucciones simples
        cv2.putText(frame, "ESPACIO=Grabar  C=Limpiar  M=Menu", (10, 110),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.4, (200, 200, 200), 1)

        # ========================
        # MOSTRAR VENTANAS
        # ========================
        cv2.imshow('Camara - Control de Manos', frame)
        cv2.imshow('Plano SCARA [-5 a 5]', plano_display)

        # ========================
        # MANEJO DE TECLAS
        # ========================
        key = cv2.waitKey(1) & 0xFF

        # ESPACIO: Iniciar/Detener grabación
        if key == ord(' '):
            recording = not recording
            if recording:
                print("\n=== GRABACION INICIADA ===")
                print("Moviendo mano... las coordenadas se enviaran al SCARA")
                movement_start_time = time.time()
                movement_blocked = False
            else:
                print("\n=== GRABACION DETENIDA ===")
                if movement_start_time:
                    duration = time.time() - movement_start_time
                    print(f"Duracion: {duration:.1f} segundos")
                    print(f"Puntos enviados: {len(full_trajectory)}")

        # 'c': Limpiar trazo/trayectoria
        elif key == ord('c'):
            reset_system()
            print("Trayectoria limpiada")

        # 'm': Volver al menú
        elif key == ord('m'):
            print("\nVolviendo al menu...")
            reset_system()
            mode = "MENU"
            cv2.destroyAllWindows()
            show_menu()

        # 'q': Salir del programa
        elif key == ord('q'):
            print("Saliendo del programa...")
            break

        # 't': Enviar posición actual manualmente
        elif key == ord('t'):
            if last_plano_position and socket_connected:
                x, y = last_plano_position
                print(f"\n>>> Enviando posición MANUAL: X={x:.2f}, Y={y:.2f}")
                if send_to_esp32_socket(x, y):
                    print("✓ Coordenada enviada manualmente")
                else:
                    print("✗ Error al enviar")

# ========================
# MANEJO DE EXCEPCIONES
# ========================
except KeyboardInterrupt:
    print("Programa interrumpido por usuario")

except Exception as e:
    print(f"Error inesperado: {e}")

finally:
    # Limpieza final
    cleanup()
